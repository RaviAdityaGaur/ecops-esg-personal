import {
  Box,
  Typography,
  Select,
  MenuItem,
  Button,
  Tabs,
  Tab,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogContentText,
  DialogActions,
  TextField,
  Grid,
} from "@mui/material";
import SidebarHeader from "../../Components/SidebarHeader";
import { useEffect, useState, useMemo, useRef } from "react"; // Add useRef here
import { useNavigate, useParams, useLocation } from "react-router-dom";
import { api, getAuthDetails } from "../common";
import { DataGrid } from "@mui/x-data-grid";
import { ProgressTracker } from "../../Components/progress-tracker";

interface TabPanelProps {
  children?: React.ReactNode;
  index: number;
  value: number;
}

function TabPanel(props: TabPanelProps) {
  const { children, value, index, ...other } = props;
  return (
    <div role="tabpanel" hidden={value !== index} {...other}>
      {value === index && <Box>{children}</Box>}
    </div>
  );
}

// Update the common box shadow style
const commonBoxShadow = "0px 2px 4px rgba(0, 0, 0, 0.1)";

// Add this common box style object
const commonBoxStyles = {
  p: 1.5,
  my: 1,
  // remove mx: 2.5
  borderRadius: 1,
  boxShadow: "0 2px 4px rgba(0,0,0,0.1)",
  cursor: "pointer",
  "&:hover": {
    boxShadow: "0 4px 8px rgba(0,0,0,0.2)",
  },
  backgroundColor: "white",
  width: "150px",
  display: "-webkit-box",
  WebkitLineClamp: 2,
  WebkitBoxOrient: "vertical",
  overflow: "hidden",
  textOverflow: "ellipsis",
  lineHeight: "1.2em",
  maxHeight: "2.4em",
  minHeight: "2.4em",
};

const commonBoxStylesWithMargin = {
  ...commonBoxStyles,
  ml: 5,
  mx: 0,
  width: "90%",
};

// Add these constants after the existing imports
const omissionOptions = [
  { value: "not_applicable", label: "Not applicable" },
  { value: "legal_prohibitions", label: "Legal prohibitions" },
  { value: "confidentiality", label: "Confidentiality constraints" },
  { value: "unavailable", label: "Information unavailable / incomplete" },
];

const placeholderMap = {
  not_applicable:
    "Explain why the disclosure or the requirement is considered not applicable.",
  legal_prohibitions: "Describe the specific legal prohibitions.",
  confidentiality: "Describe the specific confidentiality constraints.",
  unavailable:
    "Specify which information is unavailable or incomplete. When the information is incomplete, specify which part is missing (e.g., specify the entities for which the information is missing). Explain why the required information is unavailable or incomplete. Describe the steps being taken and the expected time frame to obtain the information.",
};

// Add this interface near the top of the file with other interfaces
interface DisclosureData {
  dis_id: number;
  standard_id: number;
  // ...other properties...
}

// Add this helper function to format dialog content properly
// This handles both plain text and potentially HTML content
const formatDialogContent = (content: string | null): React.ReactNode => {
  if (!content) return "No content available";

  // If the content appears to contain HTML
  if (content.includes("<")) {
    return <div dangerouslySetInnerHTML={{ __html: content }} />;
  }

  // For plain text, handle line breaks for better readability
  const formattedContent = content
    .split("\n")
    .map((line, i) => <p key={i}>{line}</p>);

  return formattedContent;
};

export default function ReportingDisclosureList() {
  const [steps] = useState([
    { id: 1, title: "Primary Information", type: "main", status: "complete" },
    {
      id: 2,
      title: "Setup External Survey",
      type: "main",
      status: "in-progress",
    },
    { id: 3, title: "Choose Standards", type: "sub", status: "complete" },
    { id: 4, title: "Choose Sectors", type: "sub", status: "complete" },
    { id: 5, title: "Choose Disclosures", type: "sub", status: "in-progress" },
    { id: 6, title: "Add Questions", type: "sub", status: "pending" },
    { id: 7, title: "Send Email", type: "sub", status: "pending" },
    { id: 8, title: "Setup Internal Survey", type: "main", status: "pending" },
  ]);

  const [activeTab, setActiveTab] = useState(0);
  const [openConfirmDialog, setOpenConfirmDialog] = useState(false);
  const [dialogOpen, setDialogOpen] = useState(false);
  const [dialogContent, setDialogContent] = useState({
    title: "",
    content: "",
  });

  // Add this new state for the detail popup
  const [detailDialog, setDetailDialog] = useState({
    open: false,
    title: "",
    content: "",
  });

  const handleDetailClick = (title: string, content: string) => {
    setDetailDialog({
      open: true,
      title,
      content,
    });
  };

  const handleTabChange = (event: React.SyntheticEvent, newValue: number) => {
    setActiveTab(newValue);
  };

  const handleConfirmDialog = () => {
    setOpenConfirmDialog(false);
  };

  const [disclosures, setDisclosures] = useState<any[]>([]);
  const [loading, setLoading] = useState(true);
  const [openDialog, setOpenDialog] = useState(false);
  const [currentRow, setCurrentRow] = useState(null);
  const [response, setResponse] = useState(null);
  const [responseMap, setResponseMap] = useState({});
  const { reportId } = useParams();
  const [omissionReason, setOmissionReason] = useState("");
  const [explanation, setExplanation] = useState("");
  const [raciValues, setRaciValues] = useState({});
  const [raciMap, setRaciMap] = useState({});

  // Add this effect to fetch RACI values
  useEffect(() => {
    const fetchRaciValues = async () => {
      try {
        const data = await api
          .get("esg/api/survey-disclosure-mapping/get_raci_values/")
          .json();
        setRaciValues(data);
      } catch (error) {
        console.error("Error fetching RACI values:", error);
      }
    };
    fetchRaciValues();
  }, []);

  // Update the handleRaciChange function
  const handleRaciChange = async (disclosureId: number, value: string) => {
    try {
      const payload = {
        survey: Number(surveyId),
        disclosure: disclosureId,
        standard: disclosures.find((d) => d.dis_id === disclosureId)
          ?.standard_id,
        raci_category: value,
        topic: null,
        for_internal: false,
        for_external: true, // Since this is DisclosureList for external survey
      };

      await api.post("esg/api/survey-disclosure-mapping/", {
        json: payload,
        headers: {
          "content-type": "application/json",
        },
      });

      setRaciMap((prev) => ({
        ...prev,
        [disclosureId]: value,
      }));
    } catch (error) {
      console.error("Error updating RACI value:", error);
    }
  };

  // Add state to track current materiality view
  const [materialityView, setMaterialityView] = useState("IMPACT");

  // Add new state for survey data
  const [surveyData, setSurveyData] = useState(null);
  //  const demoData = [
  //   {
  //       "dis_id": 100,
  //       "disclosure_id": "13.1.2",
  //       "disclosure_description": "a. Gross direct (Scope 1) GHG emissions in metric tons of CO2 equivalent. \nb. Gases included in the calculation; whether CO2 , CH4 , N2O, HFCs, PFCs, SF6 , NF3 , or all. \nc. Biogenic CO2 emissions in metric tons of CO2 equivalent. \nd. Base year for the calculation, if applicable, including: \ni. the rationale for choosing it; \nii. emissions in the base year; \niii. the context for any significant changes in emissions that triggered recalculations of base year emissions.  \ne. Source of the emission factors and the global warming potential (GWP) rates used, or a reference to the GWP source. \nf. Consolidation approach for emissions; whether equity share, financial control, or operational control.  \ng. Standards, methodologies, assumptions, and/or calculation tools used.\n\nAdditional sector recommendations\nWhen reporting on gross direct (Scope 1) GHG emissions in metric tons of CO2 equivalent, include land use change emissions.",
  //       "dimension": "Environmental",
  //       "year": 2016,
  //       "sdg_targets": [
  //           {
  //               "id": 15,
  //               "target": "3.9",
  //               "goal": 15
  //           },
  //           {
  //               "id": 9,
  //               "target": "12.2",
  //               "goal": 9
  //           },
  //           {
  //               "id": 11,
  //               "target": "13.1",
  //               "goal": 11
  //           },
  //           {
  //               "id": 13,
  //               "target": "14.2",
  //               "goal": 13
  //           },
  //           {
  //               "id": 14,
  //               "target": "15.1",
  //               "goal": 14
  //           }
  //       ],
  //       "indicator_source": {
  //           "id": 5,
  //           "name": "GRI Sustainability Reporting Standards",
  //           "description": "",
  //           "information": null,
  //           "website_url": null
  //       },
  //       "disclosure_theme": {
  //           "id": 11,
  //           "name": "Emissions",
  //           "description": "",
  //           "created_at": "2025-05-22T05:09:05.090918Z",
  //           "updated_at": "2025-05-22T05:09:05.090935Z"
  //       },
  //       "sub_topic": {
  //           "id": 29,
  //           "name": "Direct (Scope 1) GHG emissions",
  //           "description": "",
  //           "created_at": "2025-05-22T05:09:05.093589Z",
  //           "updated_at": "2025-05-22T05:09:05.093604Z"
  //       },
  //       "response": [],
  //       "report_disclosure_id": 1,
  //       "standard_id": 36,
  //       "standard_name": "GRI 13",
  //       "material_issue": [],
  //       "disclosure_type": "IMPACT"
  //   },
  //  ]
  useEffect(() => {
    const fetchDisclosuresForReport = async () => {
      if (!reportId) {
        setDisclosures([]);
        return;
      }

      setLoading(true);
      try {
        const response: any = await api
          .get(`esg/api/get-disclosure-for-report/?report_id=${reportId}`)
          .json();

        const fetched = response.disclosures ? response.disclosures : [];
        console.log("Fetched disclosures:", fetched);
        setDisclosures(fetched);

      } catch (err) {
        console.error("Error fetching disclosures:", err);
        console.log("Falling back to demoData");
      } finally {
        setLoading(false);
      }
    };

    fetchDisclosuresForReport();
  }, [reportId]);

  useEffect(() => {
    console.log("disclosures updated:", disclosures);
  }, [disclosures]);



  // Add effect to fetch survey details
  useEffect(() => {
    const fetchSurveyData = async () => {
      if (!reportId) return;

      try {
        const response = await api
          .get(`esg/api/surveys/get_surveys/?survey_id=${reportId}`)
          .json();
        if (response && response.length > 0) {
          setSurveyData(response[0]);
        }
      } catch (error) {
        console.error("Error fetching survey data:", error);
      }
    };

    fetchSurveyData();
  }, [reportId]);

  // Function to handle navigation to review page
  const handleNavigateToReview = () => {
    navigate(`/review-disclosures/${reportId}`);
  };

  // Update useEffect to handle materiality view from navigation state

  const location = useLocation();

  useEffect(() => {
    // Check if we're returning from additional disclosures with state
    if (location.state && location.state.materialityView) {
      setMaterialityView(location.state.materialityView);
    }
  }, [location]);

  // Update useEffect to handle loading disclosures based on materiality view
  /* useEffect(() => {
    const fetchData = async () => {
      try {
        setLoading(true);

        let data;

        // Check if we have a single or double survey
        const isSingleSurvey =
          surveyData && surveyData.survey_type === "single";

        if (isSingleSurvey) {
          // For single survey type, get all disclosures without filtering by disclosure_type
          const response = await api
            .get(
              `esg/api/get-disclosures-from-survey/?survey_id=${surveyId}&is_external=TRUE`
            )
            .json();

          // Don't filter by disclosure_type for single surveys
          data = response;
          console.log(
            `Found ${
              response.disclosures?.length || 0
            } disclosures for single survey`
          );
        } else if (materialityView === "FINANCIAL") {
          // Get material issues from localStorage for financial materiality
          const savedMaterialIssues = localStorage.getItem(
            `survey_${surveyId}_material_issues`
          );
          if (savedMaterialIssues) {
            const materialIssueIds = JSON.parse(savedMaterialIssues);

            // For financial materiality, fetch disclosures with disclosure_type: FINANCIAL
            if (materialIssueIds.length > 0) {
              try {
                // First try to get disclosures from material issues endpoint
                const response = await api
                  .post("esg/api/disclosures-by-material-issue/", {
                    json: {
                      survey_id: Number(surveyId),
                      material_issue_id: materialIssueIds[0], // Using the first material issue for now
                      filters: {
                        // Add any additional filters if needed
                      },
                    },
                    headers: {
                      "content-type": "application/json",
                    },
                  })
                  .json();

                // Filter to only include FINANCIAL disclosures
                const financialDisclosures = response.filter(
                  (item) => item.disclosure_type === "FINANCIAL"
                );

                if (financialDisclosures.length > 0) {
                  data = { disclosures: financialDisclosures };
                  console.log(
                    `Found ${financialDisclosures.length} financial disclosures for material issue ID ${materialIssueIds[0]}`
                  );
                } else {
                  console.log(
                    "No financial disclosures found for the selected material issue, fetching from general endpoint"
                  );
                }
              } catch (error) {
                console.error(
                  "Error fetching disclosures by material issue:",
                  error
                );
              }
            }
          }

          // If we couldn't get disclosures by material issue, fall back to regular API
          if (!data || !data.disclosures || data.disclosures.length === 0) {
            const response = await api
              .get(
                `esg/api/get-disclosures-from-survey/?survey_id=${surveyId}&is_external=TRUE&materiality_type=financial`
              )
              .json();

            // Ensure we're still filtering for FINANCIAL disclosure_type
            if (response && response.disclosures) {
              const financialDisclosures = response.disclosures.filter(
                (item) => item.disclosure_type === "FINANCIAL"
              );

              data = { disclosures: financialDisclosures };
              console.log(
                `Found ${financialDisclosures.length} financial disclosures from general endpoint`
              );
            } else {
              data = { disclosures: [] };
            }
          }
        } else {
          // For IMPACT materiality, use the original API and filter for IMPACT disclosures
          const response = await api
            .get(
              `esg/api/get-disclosures-from-survey/?survey_id=${surveyId}&is_external=TRUE&materiality_type=impact`
            )
            .json();

          if (response && response.disclosures) {
            const impactDisclosures = response.disclosures.filter(
              (item) => item.disclosure_type === "IMPACT"
            );

            data = { disclosures: impactDisclosures };
            console.log(`Found ${impactDisclosures.length} impact disclosures`);
          } else {
            data = { disclosures: [] };
          }
        }

        // Process the disclosures regardless of survey type
        const processedDisclosures = (data.disclosures || []).map(
          (item, index) => {
            // Create initial response map
            if (item.response?.length > 0) {
              setResponseMap((prev) => ({
                ...prev,
                [item.dis_id]: item.response[0].is_accepted ? "yes" : "no",
              }));
            }

            // Set initial RACI value if it exists
            if (item.raci) {
              setRaciMap((prev) => ({
                ...prev,
                [item.dis_id]: item.raci,
              }));
            }

            // Check if material_issue is an empty array
            const materialIssue =
              Array.isArray(item.material_issue) &&
              item.material_issue.length === 0
                ? null
                : item.material_issue || "N/A";

            return {
              id: index, // Ensure a unique ID for each row
              dis_id: item.dis_id,
              standard_id: item.standard_id, // Make sure this is included
              disclosure_id: item.standard_name || "N/A", // ID column shows standard_name
              material_issue: materialIssue, // Properly handle empty arrays
              disclosure_description:
                item.disclosure_description ?? "No description available",
              dimension: item.dimension ?? "N/A",
              year: item.year ?? "N/A",
              sdg_targets:
                item.sdg_targets?.map((target) => target.target).join(", ") ??
                "N/A",
              indicator_source: item.indicator_source?.name ?? "N/A",
              disclosure_theme: item.disclosure_theme?.name ?? "N/A",
              sub_topic: item.sub_topic?.name ?? "N/A",
              response:
                item.response?.length > 0
                  ? item.response.map((resp) => ({
                      id: resp.id,
                      isAccepted: resp.is_accepted,
                      optionalReason:
                        resp.optional_reason ?? "No reason provided",
                    }))
                  : null,
              hasResponse:
                Array.isArray(item.response) && item.response.length > 0, // Flag for response
              currentResponse:
                item.response?.length > 0
                  ? item.response[0].is_accepted
                    ? "yes"
                    : "no"
                  : null,
              disclosure_number: item.disclosure_id || "N/A", // Disclosure ID column shows disclosure_id
              raci: item.raci || "", // Update this line - use raci instead of raci_value
              disclosure_type: item.disclosure_type || "N/A", // Store the disclosure_type
            };
          }
        );

        setDisclosures(processedDisclosures);
        setLoading(false);
      } catch (error) {
        console.error("Error fetching data:", error);
        setLoading(false);
      }
    };
    fetchData();
  }, [surveyId, materialityView, surveyData]); // Add surveyData as dependency
  */

  const handleResponseClick = (row) => {
    setCurrentRow(row);
    setOpenDialog(true);
  };

  const handleCloseDialog = () => {
    setOpenDialog(false);
    setOmissionReason("");
    setExplanation("");
  };

  const handleSubmit = async () => {
    if (!currentRow || !omissionReason || !explanation) return;

    const auth = getAuthDetails();
    try {
      const payload = {
        survey_id: surveyId,
        disclosure_id: currentRow.dis_id,
        response_from: auth.user?.pk,
        is_accepted: false,
        is_omitted: true,
        acceptance_reason: null,
        rejection_reason: omissionReason,
        rejection_description: explanation,
        optional_reason: null,
      };

      await api.post("esg/api/survey-response/", {
        json: payload,
        headers: {
          "content-type": "application/json",
        },
      });

      // Update local state after successful API call
      setResponseMap((prev) => ({
        ...prev,
        [currentRow.dis_id]: "no",
      }));

      // Update disclosures state to reflect the new response
      setDisclosures((prevDisclosures) =>
        prevDisclosures.map((disc) =>
          disc.dis_id === currentRow.dis_id
            ? {
              ...disc,
              response: [
                {
                  id: Date.now(), // temporary id
                  isAccepted: false,
                  optionalReason: null,
                },
              ],
              hasResponse: true,
              currentResponse: "no",
            }
            : disc
        )
      );

      handleCloseDialog();
    } catch (error) {
      console.error("Error submitting response:", error);
    }
  };

  const getDimensionFromTab = (tabIndex: number): string => {
    switch (tabIndex) {
      case 0:
        return "Environmental"; // Changed to match API response
      case 1:
        return "Social";
      case 2:
        return "Governance";
      default:
        return "Environmental";
    }
  };

  // Add mapping for display names if needed
  const getDimensionDisplayName = (dimension: string): string => {
    switch (dimension.toLowerCase()) {
      case "environmental":
        return "Environment";
      case "social":
        return "Social";
      case "governance":
        return "Governance";
      default:
        return dimension;
    }
  };

  const filteredDisclosures = useMemo(() => {
    if (!disclosures || disclosures.length === 0) return [];

    const currentDimension = getDimensionFromTab(activeTab);
    return disclosures.filter(
      (disclosure) => disclosure.dimension === currentDimension // Removed toLowerCase()
    );
  }, [disclosures, activeTab]);

  // Add this new state to track disclosures with missing data
  const [missingDataDisclosures, setMissingDataDisclosures] = useState({
    responses: [] as number[],
    riskCategories: [] as number[],
  });

  // Add reference to DataGrid
  const dataGridRef = useRef(null);

  // Add this function to check and mark disclosures with missing data
  const checkMissingData = () => {
    if (!disclosures || disclosures.length === 0) return;

    const missingResponses = disclosures
      .filter((disclosure) => !responseMap[disclosure.dis_id])
      .map((disclosure) => disclosure.id);

    const missingRiskCategories = disclosures
      .filter((disclosure) => !raciMap[disclosure.dis_id])
      .map((disclosure) => disclosure.id);

    setMissingDataDisclosures({
      responses: missingResponses,
      riskCategories: missingRiskCategories,
    });

    return { missingResponses, missingRiskCategories };
  };

  // Call this whenever responses or risk categories change
  useEffect(() => {
    checkMissingData();
  }, [responseMap, raciMap, disclosures]);

  const columns = [
    {
      field: "disclosure_id",
      headerName: "Standard",
      flex: 0.8, // Use flex instead of width for responsive sizing
      minWidth: 100, // Set a minimum width to avoid too narrow columns
      renderCell: (params) => (
        <Box
          sx={{
            pl: 2,
            color:
              missingDataDisclosures.responses.includes(params.row.id) ||
                missingDataDisclosures.riskCategories.includes(params.row.id)
                ? "#DF0404"
                : "inherit",
            fontWeight:
              missingDataDisclosures.responses.includes(params.row.id) ||
                missingDataDisclosures.riskCategories.includes(params.row.id)
                ? "bold"
                : "normal",
          }}
        >
          {params.value}
        </Box>
      ),
    },
    {
      field: "material_issue",
      headerName: "Material Topic",
      flex: 1.2,
      minWidth: 110,
      renderCell: (params) => {
        if (!params.row.material_issue) {
          return null;
        }

        return (
          <Box
            sx={commonBoxStyles}
            onClick={() =>
              handleDetailClick(
                "Material Issue",
                params.row.material_issue || "No material issue specified"
              )
            }
          >
            {params.row.material_issue || "N/A"}
          </Box>
        );
      },
    },
    {
      field: "standard_name",
      headerName: "Topic standard ",
      flex: 1.2,
      minWidth: 110,
      renderCell: (params) => (
        <Box
          sx={commonBoxStyles}
          onClick={() =>
            handleDetailClick("Theme", params.row.standard_name)
          }
        >
          {params.row.standard_name}
        </Box>
      ),
    },
    {
      field: "sub_topic",
      headerName: "Sub Topic",
      flex: 1, // Use flex instead of width
      minWidth: 110,
      renderCell: (params) => (
        <Box
          sx={commonBoxStylesWithMargin} // With left margin
          onClick={() => handleDetailClick("Sub Topic", params.row.sub_topic)}
        >
          {params.row.sub_topic.name}
        </Box>
      ),
    },
    {
      field: "disclosure_description",
      headerName: "Description",
      flex: 1.2, // Give description a bit more space with higher flex
      minWidth: 130,
      renderCell: (params) => (
        <Box
          sx={commonBoxStylesWithMargin}
          onClick={() =>
            handleDetailClick("Description", params.row.disclosure_description)
          }
        >
          {params.row.disclosure_description}
        </Box>
      ),
    },
    {
      field: "disclosure_number", // New field for Disclosure ID
      headerName: "Disclosure ID",
      flex: 1,
      minWidth: 110,
      renderCell: (params) => (
        <Box
          sx={commonBoxStylesWithMargin}
          onClick={() =>
            handleDetailClick(
              "Disclosure ID",
              params.row.disclosure_id || "Not assigned"
            )
          }
        >
          {params.row.disclosure_id || "Not assigned"}
        </Box>
      ),
    },
    {
      field: "sdg_goal", // New field for Disclosure ID
      headerName: "SDG Goal",
      flex: 1,
      minWidth: 110,
      renderCell: (params) => (
        <Box
          sx={commonBoxStylesWithMargin}
          onClick={() =>
            handleDetailClick(
              "SDG Goal",
              params.row.sdg_targets?.map((item: any) => item.goal).join(", ") || "Not assigned"
            )
          }
        >
          {params.row.sdg_targets?.map((item: any) => item.goal).join(", ") || "Not assigned"}

        </Box>
      ),
    },
    {
      field: "sdg_traget", // New field for Disclosure ID
      headerName: "SDG Traget",
      flex: 1,
      minWidth: 110,
      renderCell: (params) => (
        <Box
          sx={commonBoxStylesWithMargin}
          onClick={() =>
            handleDetailClick(
              "SDG Traget",
              params.row.sdg_targets?.map((item: any) => item.target).join(", ") || "Not assigned"
            )
          }
        >
          {params.row.sdg_targets?.map((item: any) => item.target).join(", ") || "Not assigned"}

        </Box>
      ),
    },
    {
      field: "rating", // New field for Disclosure ID
      headerName: "Rating",
      flex: 1,
      minWidth: 110,
      renderCell: (params) => (
        <Box
          sx={commonBoxStylesWithMargin}
          onClick={() =>
            handleDetailClick(
              "Rating",
              // params.row.sdg_targets?.map((item: any) => item.goal).join(", ") ||
              "Not assigned"
            )
          }
        >
          {
            // params.row.sdg_targets?.map((item: any) => item.target).join(", ") || 
            "Not assigned"}

        </Box>
      ),
    },
    {
      field: "response",
      headerName: "Response",
      flex: 0.9,
      minWidth: 100,
      renderCell: (params) => {
        const currentValue = responseMap[params.row.dis_id] || "";
        const isMissingResponse = missingDataDisclosures.responses.includes(
          params.row.id
        );

        const handleClick = () => {
          const selectElement = document.getElementById(
            `response-select-${params.row.id}`
          );
          if (selectElement) {
            selectElement.click();
          }
        };

        return (
          <Box
            onClick={handleClick}
            sx={{
              borderRadius: "4px",
            }}
          >
            <Select
              id={`response-select-${params.row.dis_id}`}
              fullWidth
              value={currentValue}
              onChange={(e) =>
                handleResponseChange(params.row.dis_id, e.target.value)
              }
              displayEmpty
              sx={{
                height: "100%",
                width: "80%",
                cursor: "pointer",
                border: isMissingResponse ? "2px solid #DF0404" : "none",
                borderRadius: "6px",
                "& .MuiSelect-select": {
                  p: "0 15px 0 15px",
                  height: "100% !important",
                  display: "flex",
                  alignItems: "center",
                  justifyContent: "center",
                  backgroundColor:
                    currentValue === "yes"
                      ? "#147C65"
                      : currentValue === "no"
                        ? "#DF0404"
                        : isMissingResponse
                          ? "rgba(255, 235, 235, 0.8)"
                          : "white",
                  color: currentValue
                    ? "white"
                    : isMissingResponse
                      ? "#DF0404"
                      : "#64748B",
                },
                "& .MuiOutlinedInput-notchedOutline": {
                  border: currentValue
                    ? "none"
                    : isMissingResponse
                      ? "1px solid #DF0404"
                      : "1px solid #E0E0E0",
                  borderRadius: "4px",
                },
                "& .MuiSelect-icon": {
                  right: 0,
                  color: currentValue
                    ? "white"
                    : isMissingResponse
                      ? "#DF0404"
                      : "#64748B",
                },
              }}
              MenuProps={{
                PaperProps: {
                  sx: {
                    mt: 1,
                    boxShadow: "0px 2px 4px rgba(0,0,0,0.1)",
                  },
                },
              }}
            >
              <MenuItem value="" sx={{ justifyContent: "center" }}>
                {isMissingResponse ? (
                  <Box sx={{ color: "#DF0404", fontWeight: "bold" }}>
                    Required
                  </Box>
                ) : (
                  "Yes/No"
                )}
              </MenuItem>
              <MenuItem
                value="yes"
                sx={{
                  justifyContent: "center",
                  color: "#147C65",
                  "&.Mui-selected": {
                    backgroundColor: "#147C65",
                    color: "white",
                  },
                }}
              >
                Yes
              </MenuItem>
              <MenuItem
                value="no"
                sx={{
                  justifyContent: "center",
                  color: "#DF0404",
                  "&.Mui-selected": {
                    backgroundColor: "#DF0404",
                    color: "white",
                  },
                }}
              >
                No
              </MenuItem>
            </Select>
          </Box>
        );
      },
    },
  ];

  const handleYesResponse = async (row, value) => {
    const auth = getAuthDetails();
    try {
      const payload = {
        survey_id: surveyId,
        disclosure_id: row.dis_id,
        response_from: auth.user?.pk,
        is_accepted: true,
        is_omitted: false,
        acceptance_reason: 1,
        rejection_reason: null,
        rejection_description: null,
        optional_reason: null,
        omission_reason: null,
      };

      await api.post("esg/api/survey-response/", {
        json: payload,
        headers: {
          "content-type": "application/json",
        },
      });

      // Update local state after successful API call
      setResponseMap((prev) => ({
        ...prev,
        [row.dis_id]: value,
      }));

      // Update disclosures state to reflect the new response
      setDisclosures((prevDisclosures) =>
        prevDisclosures.map((disc) =>
          disc.dis_id === row.dis_id
            ? {
              ...disc,
              response: [
                {
                  id: Date.now(), // temporary id
                  isAccepted: true,
                  optionalReason: null,
                },
              ],
              hasResponse: true,
              currentResponse: "yes",
            }
            : disc
        )
      );
    } catch (error) {
      console.error("Error submitting response:", error);
    }
  };

  // Modify the handleResponseChange function to handle "No" responses directly
  const handleResponseChange = async (rowId: number, value: string) => {
    console.log("rowid", rowId, "value", value, "disclosures", disclosures)
    const row = disclosures.find((d) => d.dis_id === rowId);
    console.log("row", row)
    if (!row) return;

    const auth = getAuthDetails();
    try {
      const payload =
      {
        "report_id": reportId,
        "disclosure_id": row.dis_id,
        // "is_omitted": false,
        // "omission_description": "string",
        // "rejection_reason": 0,
        "is_added": value == 'yes' ? true : false,
        "is_removed":  value == 'no' ? true : false,
      }
      console.log("payload", payload)
      const response = await api.post("esg/api/report-disclosure-response/", {
        json: payload,
        headers: {
          "content-type": "application/json",
        },
      });

      console.log("res", response)

      // Update local state after successful API call
      setResponseMap((prev) => ({
        ...prev,
        [row.dis_id]: value,
      }));

      // Update disclosures state to reflect the new response
      setDisclosures((prevDisclosures) =>
        prevDisclosures.map((disc) =>
          disc.dis_id === row.dis_id
            ? {
              ...disc,
              response: [
                {
                  id: Date.now(), // temporary id
                  isAccepted: value === "yes",
                  optionalReason: null,
                },
              ],
              hasResponse: true,
              currentResponse: value,
            }
            : disc
        )
      );
    } catch (error) {
      console.error("Error submitting response:", error);
    }
  };

  const [openProceedDialog, setOpenProceedDialog] = useState(false);
  const navigate = useNavigate();

  // Add state to track completed responses
  const [requiredResponsesComplete, setRequiredResponsesComplete] =
    useState(false);

  // Calculate disclosure counts for each dimension
  const dimensionCounts = useMemo(() => {
    if (!disclosures || disclosures.length === 0)
      return {
        Environmental: 0,
        Social: 0,
        Governance: 0,
      };

    return disclosures.reduce((acc, disclosure) => {
      if (disclosure.dimension) {
        acc[disclosure.dimension] = (acc[disclosure.dimension] || 0) + 1;
      }
      return acc;
    }, {} as Record<string, number>);
  }, [disclosures]);

  // Check if all disclosures have responses
  useEffect(() => {
    if (disclosures.length === 0) {
      setRequiredResponsesComplete(false);
      return;
    }

    const allResponsesProvided = disclosures.every(
      (disclosure) =>
        responseMap[disclosure.dis_id] === "yes" ||
        responseMap[disclosure.dis_id] === "no"
    );

    setRequiredResponsesComplete(allResponsesProvided);
  }, [disclosures, responseMap]);

  // Modify handleNextClick to handle both types of surveys
  const handleNextClick = async () => {
    if (!surveyId) {
      alert("Survey ID not found.");
      return;
    }

    // Check for missing data and get the details
    const { missingResponses, missingRiskCategories } = checkMissingData() || {
      missingResponses: [],
      missingRiskCategories: [],
    };

    // If we have missing data, show specific warning
    if (missingResponses.length > 0 || missingRiskCategories.length > 0) {
      // Switch to tab containing first missing item if needed
      if (missingResponses.length > 0 || missingRiskCategories.length > 0) {
        const firstMissingId = [
          ...missingResponses,
          ...missingRiskCategories,
        ][0];
        const firstMissingItem = disclosures.find(
          (d) => d.id === firstMissingId
        );

        if (firstMissingItem) {
          const tabIndex =
            {
              Environmental: 0,
              Social: 1,
              Governance: 2,
            }[firstMissingItem.dimension] || 0;

          if (activeTab !== tabIndex) {
            setActiveTab(tabIndex);
          }

          // Construct warning message
          let warningMessage = "";
          if (missingResponses.length > 0) {
            const mismatchedDisclosures = disclosures
              .filter((d) => missingResponses.includes(d.id))
              .map(
                (d) =>
                  `• ${d.disclosure_id} (${d.disclosure_number || "ID not assigned"
                  })`
              )
              .slice(0, 5)
              .join("\n");

            warningMessage += `Missing Yes/No responses for ${missingResponses.length} disclosure(s):\n${mismatchedDisclosures}`;
            if (missingResponses.length > 5) {
              warningMessage += `\n... and ${missingResponses.length - 5} more`;
            }
          }

          if (missingRiskCategories.length > 0) {
            if (warningMessage) warningMessage += "\n\n";
            const mismatchedRiskDisclosures = disclosures
              .filter((d) => missingRiskCategories.includes(d.id))
              .map(
                (d) =>
                  `• ${d.disclosure_id} (${d.disclosure_number || "ID not assigned"
                  })`
              )
              .slice(0, 5)
              .join("\n");

            warningMessage += `Missing risk categories for ${missingRiskCategories.length} disclosure(s):\n${mismatchedRiskDisclosures}`;
            if (missingRiskCategories.length > 5) {
              warningMessage += `\n... and ${missingRiskCategories.length - 5
                } more`;
            }
          }

          setDialogContent({
            title: "Missing Required Fields",
            content: warningMessage,
          });
          setDialogOpen(true);
        }
      }
      return;
    }

    // Check if this is a double survey and we're currently showing impact materiality
    if (
      surveyData &&
      surveyData.survey_type === "double" &&
      materialityView === "IMPACT"
    ) {
      try {
        // Get material issues from localStorage
        const savedMaterialIssues = localStorage.getItem(
          `survey_${surveyId}_material_issues`
        );
        if (savedMaterialIssues) {
          const materialIssueIds = JSON.parse(savedMaterialIssues);

          if (materialIssueIds.length > 0) {
            // Get the standard_id - you'll need to determine the appropriate way to get this
            // One approach is to get it from the first disclosure that matches the material issue
            const standardId = disclosures.find(
              (d) =>
                d.material_issue &&
                (Array.isArray(d.material_issue)
                  ? d.material_issue.includes(materialIssueIds[0])
                  : d.material_issue === materialIssueIds[0])
            )?.standard_id;

            await api.post(
              "esg/api/map-financial-disclosures-by-material-issue/",
              {
                json: {
                  material_issue_ids: materialIssueIds,
                  survey_id: Number(surveyId),
                  is_external: true,
                },
                headers: {
                  "content-type": "application/json",
                },
              }
            );

            console.log(
              "Successfully mapped financial disclosures for material issues:",
              materialIssueIds,
              "with standard ID:",
              standardId
            );
          }
        }

        // Switch to financial materiality view
        setMaterialityView("FINANCIAL");
        setDisclosures([]);
        setLoading(true);
        setResponseMap({});
        setRaciMap({});
        setMissingDataDisclosures({
          responses: [],
          riskCategories: [],
        });
      } catch (error) {
        console.error("Error mapping financial disclosures:", error);
        alert("Error preparing financial materiality view. Please try again.");
      }

      return;
    }

    // If it's already financial materiality or not a double survey, proceed to questions
    try {
      await api.post("esg/api/surveys/update_status/", {
        body: JSON.stringify({
          survey_id: surveyId,
          status: "OPEN_ENDED_QUESTIONS",
        }),
        headers: {
          "Content-Type": "application/json",
        },
      });

      // Clean up localStorage when moving to the next step
      localStorage.removeItem(`survey_${surveyId}_material_issues`);

      // Navigate to questions
      navigate(`/questions/${surveyId}`);
    } catch (error) {
      console.error("Error updating survey:", error);
      alert("An error occurred. Please try again.");
    }
  };

  const handleAddMoreDisclosures = () => {
    // Pass the current materiality view as a URL parameter
    navigate(
      `/report-additional-disclosures/${reportId}?materiality=${materialityView}`
    );
  };

  const handleBackClick = () => {
    navigate(-1);
  };

  function CustomNoRowsOverlay() {
    return (
      <Box
        sx={{
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          height: "100%",
        }}
      >
        <Typography sx={{ color: "#64748B" }}>
          No disclosures available
        </Typography>
      </Box>
    );
  }

  return (
    <SidebarHeader>
      <Box sx={{ backgroundColor: "white", p: 3, borderRadius: 2 }}>
        <Box sx={{ mb: 4, mt: 1 }}>
          <ProgressTracker steps={steps} />
        </Box>
        
        <Typography variant="h6" sx={{ mb: 2 }}>
          Select Disclosures
        </Typography>

        {/* Material Tab selector */}
        <Box sx={{ width: "100%", mt: 2 }}>
          <Tabs
            value={activeTab}
            onChange={handleTabChange}
            aria-label="Materiality tabs"
            sx={{
              mb: 2,
              "& .MuiTab-root": {
                textTransform: "none",
                minWidth: "unset",
                px: 2,
              },
              "& .Mui-selected": {
                color: "#147C65 !important",
                fontWeight: "bold",
              },
              "& .MuiTabs-indicator": {
                backgroundColor: "#147C65",
              },
            }}
          >
            <Tab label="Environmental" value={0} />
            <Tab label="Social" value={1} />
            <Tab label="Governance" value={2} />
          </Tabs>

          {/* Tab Panels with DataGrid */}
          {/* ...existing tab panels code... */}
        </Box>
      </Box>

      {/* Add a Next button to navigate to review page */}
      <Box sx={{ display: 'flex', justifyContent: 'flex-end', mt: 2 }}>
        <Button
          variant="contained"
          sx={{
            bgcolor: "#147C65",
            "&:hover": { bgcolor: "#125e4d" },
            color: "white",
            textTransform: "none",
          }}
          onClick={handleNavigateToReview}
        >
          Next: Review Disclosures
        </Button>
      </Box>
      
      {/* ...existing dialogs code... */}
    </SidebarHeader>
  );
}

const ConfirmationDialog = ({
  open,
  onClose,
  onConfirm,
  disclosureCount,
}: {
  open: boolean;
  onClose: () => void;
  onConfirm: () => void;
  disclosureCount: number;
}) => {
  const navigate = useNavigate();

  const handleConfirm = () => {
    onConfirm();
    navigate("/open-ended-question");
  };

  return (
    <Dialog open={open} onClose={onClose}>
      <DialogTitle
        sx={{ color: "#40444D", fontSize: "16px", fontWeight: "600" }}
      >
        Confirm and Next
      </DialogTitle>
      <DialogContent
        sx={{
          padding: "20px 0px !important",
          width: "900px",
          height: "120px",
        }}
      >
        <DialogContentText
          sx={{
            color: "black",
            fontSize: "13px",
            fontWeight: 600,
            backgroundColor: "#F8FAFC",
            width: "100%",
            padding: "7px 22px",
          }}
        >
          {`Total Disclosure = ${disclosureCount}`}
        </DialogContentText>
        <DialogContentText
          sx={{
            color: "#40444D",
            fontSize: "15px",
            padding: "10px 10px 5px 22px",
          }}
        >
          Are you sure you want to continue with{" "}
          <span style={{ fontWeight: "600" }}>
            {`${disclosureCount} disclosures.`}
          </span>
        </DialogContentText>
      </DialogContent>
      <DialogActions>
        <Button
          onClick={handleConfirm}
          autoFocus
          sx={{
            backgroundColor: "#147C65",
            borderRadius: 1.5,
            marginRight: 2,
            color: "white",
            padding: "8px 22px",
            mb: 2,
            width: "20%",
            textTransform: "none",
            "&:hover": {
              backgroundColor: "#147C65",
            },
          }}
        >
          Confirm
        </Button>
      </DialogActions>
    </Dialog>
  );
};
